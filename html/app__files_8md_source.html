<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PRISMS-PF: /Users/stephendewitt/Documents/workspace/PRISMS_workspace/prismspf-manual/user_manual/app_files/app_files.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_pic.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PRISMS-PF
   &#160;<span id="projectnumber">v2.1</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('app__files_8md.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/Users/stephendewitt/Documents/workspace/PRISMS_workspace/prismspf-manual/user_manual/app_files/app_files.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="app__files_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Other App Files {#app_files}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;This section details the files that define each application. The norm is that substantial modifications to these files consistute a new application (in contrast to simply making changes to the input file (&#39;parameters.in&#39;). Modifying these files may require some knowledge of C++.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;A very brief description of the purpose of each of these files is below, an in-depth discussion can be found in the following subsections:</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;- equations.cc: Specifies the attributes of the model variables and the model&#39;s residual equations</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;- ICs\_and\_BCs.cc: Specifies the initial conditions for each variable (unless the initial condition is read from file) and non-uniform Dirichlet boundary conditions, if applicable.</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;- postprocess.cc: Specifies variable other than the primary model variables to output, as well as the expressions to derive these variables.</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;- nucleation.cc: Contains the function that determines the probability density of nucleation.</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;- customPDE.h: Contains the prototypes of the functions for the application, also contains declarations of the model constants given in the input file.</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;- main.cc: Main C++ function that controls the flow of the simulation. Identical for all the example applications and it is unlikely that users will need to modify it.</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;In all of these files, the user can access user inputs from parameters.in via the &#39;&#39;userInputs&#39;&#39; object (e.g. the domain size, the time step size). See the documentation entry for userInputParameters for a list of variable names inside &#39;&#39;userInputs&#39;&#39;.</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;## equations.cc</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;The file &#39;&#39;equations.cc&#39;&#39; contains a list of the variables in the model equations and their attributes as well as the residuals for the model equations. The file contains four functions: loadVariableAttributes, explicitEquationRHS, nonExplicitEquationRHS, and equationLHS.</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;To modify the functions in this file, one needs to be familiar with the weak form of the governing equations. In PRISMS-PF, the governing equations are expressed in two terms. The first is the part of the integrand that is multiplied by the test function (marked by &#39;eq&#39; with the subscript of the variable in the example below). The second is the part of the integrand that multiplied by the gradient of the test function (marked by &#39;eqx&#39; with the subscript of the variable in the example below). For the coupled Cahn-Hilliard/Allen-Cahn system, the governing equations are</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;\f$\int_{\Omega}   w  \eta^{n+1}  ~dV =\int_{\Omega}  w  \left( \underbrace{\eta^{n} - \Delta t M_{\eta}~ ((f_{\beta,c}^n-f_{\alpha,c}^n)H_{,\eta}^n)}_{eq_{\eta}} \right)+ \nabla w \cdot \underbrace{(- \Delta t M_{\eta}\kappa) \nabla \eta^{n}}_{eqx_{\eta}} ~dV \f$</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;and</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;\f$\int_{\Omega}   w  c^{n+1}  ~dV = \int_{\Omega}   w \underbrace{c^{n}}_{eq_c} +  \nabla w   \underbrace{(-\Delta t M_{c})~ [~(f_{\alpha,cc}^n(1-H^{n+1})+f_{\beta,cc}^n H^{n+1}) \nabla c + ~((f_{\beta,c}^n-f_{\alpha,c}^n)H^{n+1}_{,\eta} \nabla \eta) ] }_{eqx_{c}} ~dV \f$</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;for the Allen-Cahn and Cahn-Hilliard equation, respectively. Each of the terms in the governing equation is marked with an underbrace. The terms multiplied by the test function are referred to as the value terms and the terms multiplied by the gradient of the test function are referred to as the gradient terms.</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;### loadVariableAttributes</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;Here is the &#39;loadVariableAttributes&#39; function for the coupled Allen-Cahn/Cahn-Hilliard example application:</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;```</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;void variableAttributeLoader::loadVariableAttributes(){</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;   // Variable 0</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;   set_variable_name               (0,&quot;c&quot;);</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;   set_variable_type               (0,SCALAR);</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;   set_variable_equation_type      (0,EXPLICIT_TIME_DEPENDENT);</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    set_dependencies_value_term_RHS(0, &quot;c&quot;);</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    set_dependencies_gradient_term_RHS(0, &quot;n,grad(c)&quot;);</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    // Variable 1</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;   set_variable_name               (1,&quot;n&quot;);</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;   set_variable_type               (1,SCALAR);</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;   set_variable_equation_type      (1,EXPLICIT_TIME_DEPENDENT);</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    set_dependencies_value_term_RHS(1, &quot;c,n&quot;);</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    set_dependencies_gradient_term_RHS(1, &quot;grad(n)&quot;);</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;}</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;```</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;This function specifies the model variables and their attributes. In this case, the two model variables are the concentration, **c**, and the order parameter, **n**. Here, **c** is listed as the zeroth variable and **n** is listed as the first. For each variable, a series of attributes are set using a series of C++ function calls. The following table lists the functions and a description of the attributes they set:</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;| Function          | Options | Required | Default | Description |</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;| --------------|---------|----------|---------|----------------------------------------------------|</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;set_variable_name | String | no | var  | Sets the name of the variable. This name is used in &#39;parameters.in&#39; as well as during output.</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;set_variable_type | SCALAR, VECTOR | no | SCALAR  | Sets whether the variable is a scalar or a vector.</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;set_variable_equation_type | EXPLICIT_TIME_DEPENDENT, AUXILIARY, TIME_INDEPENDENT | no | EXPLICIT_TIME_DEPENDENT  | Sets whether the governing equation for the variable is a time-dependent PDE (EXPLICIT_TIME_DEPENDENT), a time-independent PDE that does not require a linear solve (AUXILIARY) or a time independent PDE that does require a (non)linear solve (TIME_INDEPENDENT).</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;set_dependencies_value_term_RHS | [a string] | yes | | Sets which variables and their derivatives are needed to calculate the value term for the RHS. Variables are referenced by their names. First derivatives are referenced by ```grad``` and then the variable name in parentheses. Second derivatives are referenced by ```hess``` and then the variable name in parentheses.</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;set_dependencies_gradient_term_RHS | [a string] | yes | | Sets which variables and their derivatives are needed to calculate the gradient term for the RHS. Variables are referenced by their names. First derivatives are referenced by ```grad``` and then the variable name in parentheses. Second derivatives are referenced by ```hess``` and then the variable name in parentheses.</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;set_dependencies_value_term_LHS | [a string] | no | &quot;&quot; | Sets which variables and their derivatives are needed to calculate the value term for the RHS. Variables are referenced by their names. First derivatives are referenced by ```grad``` and then the variable name in parentheses. Second derivatives are referenced by ```hess``` and then the variable name in parentheses. (Only needed for TIME_INDEPENDENT equations.)</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;set_dependencies_gradient_term_LHS | [a string] | no | &quot;&quot; | Sets which variables and their derivatives are needed to calculate the gradient term for the RHS. Variables are referenced by their names. First derivatives are referenced by ```grad``` and then the variable name in parentheses. Second derivatives are referenced by ```hess``` and then the variable name in parentheses. (Only needed for TIME_INDEPENDENT equations.)</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;set_allowed_to_nucleate | Boolean | no | false | Sets whether the nucleation algorithms should be activated for this variable. (Only needed when nucleation is desired).</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;set_need_value_nucleation | Boolean | no | false | Sets whether the value of the variable is needed to calculate the nucleation probability in the &#39;nucleation.cc&#39; file. (Only needed when nucleation is desired).</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;Some of these function calls are not present in the &#39;equations.cc&#39; file for the coupledCahnHilliardAllenCahn application. Use of the LHS function calls can be found in the preciptiateEvolution application (among others) and use the nucleation function calls can be found the nucleationModel and nucleationModel_preferential applications.</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;### explicitEquationRHS</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;The &#39;explicitEquationRHS&#39; function is where the terms in the RHS of the governing equations for EXPLICIT_TIME_DEPENDENT equations are entered. The terms in the RHS of other equations are entered into the &#39;nonExplicitEquationRHS&#39; function. Here is the &#39;explicitEquationRHS&#39; function from the coupled Allen-Cahn/Cahn-Hilliard example application:</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;```</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;template &lt;int dim, int degree&gt;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;void customPDE&lt;dim,degree&gt;::explicitEquationRHS(variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; variable_list,</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                dealii::Point&lt;dim, dealii::VectorizedArray&lt;double&gt; &gt; q_point_loc) const {</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;// --- Getting the values and derivatives of the model variables ---</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;//c</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;scalarvalueType c = variable_list.get_scalar_value(0);</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;scalargradType cx = variable_list.get_scalar_gradient(0);</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;//n</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;scalarvalueType n = variable_list.get_scalar_value(1);</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;scalargradType nx = variable_list.get_scalar_gradient(1);</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;// --- Setting the expressions for the terms in the governing equations ---</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;// Free energy for each phase and their first and second derivatives</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;scalarvalueType fa = (-1.6704-4.776*c+5.1622*c*c-2.7375*c*c*c+1.3687*c*c*c*c);</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;scalarvalueType fac = (-4.776 + 10.3244*c - 8.2125*c*c + 5.4748*c*c*c);</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;scalarvalueType facc = (10.3244-16.425*c+16.4244*c*c);</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;scalarvalueType fb = (5.0*c*c-5.9746*c-1.5924);</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;scalarvalueType fbc = (10.0*c-5.9746);</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;scalarvalueType fbcc = constV(10.0);</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;// Interpolation function and its derivative</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;scalarvalueType h = (10.0*n*n*n-15.0*n*n*n*n+6.0*n*n*n*n*n);</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;scalarvalueType hn = (30.0*n*n-60.0*n*n*n+30.0*n*n*n*n);</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;// Residual equations</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;scalargradType mux = ( cx*((1.0-h)*facc+h*fbcc) + nx*((fbc-fac)*hn) );</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;scalarvalueType eq_c = c;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;scalargradType eqx_c = (constV(-Mc*userInputs.dtValue)*mux);</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;scalarvalueType eq_n = (n-constV(userInputs.dtValue*Mn)*(fb-fa)*hn);</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;scalargradType eqx_n = (constV(-userInputs.dtValue*Kn*Mn)*nx);</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;// --- Submitting the terms for the governing equations ---</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;// Terms for the equation to evolve the concentration</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;variable_list.set_scalar_value_term_RHS(0,eq_c);</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;variable_list.set_scalar_gradient_term_RHS(0,eqx_c);</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;// Terms for the equation to evolve the order parameter</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;variable_list.set_scalar_value_term_RHS(1,eq_n);</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;variable_list.set_scalar_gradient_term_RHS(1,eqx_n);</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;}</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;```</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;In this function the residuals at a particular quadrature point are calculated. The inputs to this function are a list of the model variable values and derivatives, variable_list and a point giving access to (x,y,z) coordinates, q_point_loc. The residual terms are added to variable_list as the output. The first few lines of the function set more convenient names for the variables and their derivatives. By convention, the value of the variable is denoted by the variable name (c for the concentration and n for the structural order parameter in this case), the list of first derivatives is denoted by the variable name followed by an &#39;&#39;x&#39;&#39;, and second derivatives are denoted by the variable name followed by &#39;&#39;xx&#39;&#39;. Each variable in variable can be accessed by the index it was given in loadVariableAttributes. The variable value and the derivatives can be accessed through the get_scalar_value,  get_scalar_gradient, and get_scalar_hessian object members for scalar variables and the  get_vector_value,  get_vector_gradient, and get_vector_hessian functions. The data type for the value of a scalar variable is scalarvalueType (a scalar), the data type for the first derivatives of a scalar variable is scalargradType (a vector with a length equal to the number of dimensions), and the data type for the second derivatives of a scalar variable is scalarhessType (a matrix with a size equal to the number of dimensions by the number of dimensions). For vector variables, the data types are vectorvalueType (a vector with length equal to the number of dimensions), vectorgradType (a matrix with a size equal to the number of dimensions by the number of dimensions), and vectorgradType (a rank-three tensor with a size in each direction equal to the number of dimensions).</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;After the nicknames for the field variables are set, the residual terms are calculated (including some intermediate variables, such as the free energies and the interpolation functions in the example above). These use the same six data types discussed in the preceding paragraph. The model variables given in &#39;parameters.in&#39; can be used to define the residual terms.</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;Finally, the terms for the governing equations are submitted to variable_list, using the functions set_scalar_value_term_RHS, set_scalar_gradient_term_RHS, set_vector_value_term_RHS, and set_vector_gradient_term_RHS, once again referring the variables by their index.</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;The nickname step can be skipped, if desired, although the code is generally more readable with nicknames (and the performance overhead is minimal). An example without nicknames for the fields can be found in the grainGrowth application, where loops over the ten variables are easier to construct when not declaring all of the variables at once. One word of caution, though: calling set_scalar_value_term_RHS and set_scalar_gradient_term_RHS overwrites the value and gradient of the variable, respectively (and same for the variants for vectors). Thus, either the residuals need to be cached and then set after all the residuals have been calculated (as is done in the grainGrowth application) or the values and gradients need to be cached before setting the residuals (as is done with the standard nicknaming approach).</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;#### A note on types</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;The deal.II library uses a data structure called a VectorizedArray to store the variable values and their derivatives. This data structured in optimized for modern vectorized processors, giving a substantial speedup in some cases. However, this data structure can complicate things slightly. One complicating factor is that VectorizedArrays can&#39;t always be added, subtracted, multiplied, or divided with more standard data types like doubles. For this reason, you will see the &#39;&#39;constV(argument)&#39;&#39; function scattered throughout the code. This function turns a non-VectorizedArray into a VectorizedArray. To be safe, you can always encase non-VectorizedArrays with &#39;&#39;constV()&#39;&#39; when they share an operation with a VectorizedArray. A second complication is that not all of the standard mathematical operations are available for VectorizedArrays. The basic trigonometric functions are available, as are exponentials and square roots. However, hyperbolic tangents are not. If needed, they must be constructed from exponents (or by iterating through the VectorizedArray, see below). A third complication is that conditional statements involving VectorizedArrays are not allowed. To perform a conditional statement, you must iterate through the VectorizedArray. To do still, construct a for loop where the maximum index is [variable name].n_array_elements. For examples of this, refer to the postprocessing file for the grainGrowth app or the seedNucleus function in &#39;equations.cc&#39; in the nucleationModel app. For more details on the deal.II implementation of VectorizedArrays (including a list of mathematical operations that are allowed), please visit [the relevant deal.II documentation page](https://www.dealii.org/8.4.0/doxygen/deal.II/classVectorizedArray.html).</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;### nonExplicitEquationRHS</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;The &#39;nonExplicitEquationRHS&#39; function is where the terms in the RHS of the governing equations for AUXILIARY and TIME_INDEPENDENT equations are entered. The terms in the RHS of EXPLICIT_TIME_DEPENDENT equations are entered into the &#39;explicitEquationRHS&#39; function. The structure and use is otherwise identical to &#39;explicitEquationRHS&#39;. Examples of apps where this function is used include cahnHilliard (for an AUXILIARY equation) and MgNd_precipitate_single_Bppp (for AUXILIARY and TIME_INDEPENDENT equations).</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;### equationLHS</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;In the coupledCahnHilliardAllenCahn app, the equationLHS function is empty because it is only needed for TIME_INDEPENDENT PDEs (or more specifically, when a non-trivial matrix inversion needs to be performed). Here we go through the equationLHS function from the precipitateEvolution application, where the equation for mechanical equilibrium is TIME_INDEPENDENT.</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;From the formulation file in the precipitateEvolution application, the governing equation for the mechanical displacement is:</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;\f$</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;R(u) = \int_{\Omega}   \nabla w :  C(\eta_1, \eta_2, \eta_3) : \left( \epsilon - \epsilon^0(c,\eta_1, \eta_2, \eta_3)\right) ~dV = 0</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;\f$</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;In PRISMS-PF, matrix inversion problems are always written as Newton&#39;s method iterations. For linear equations, like the one above, the solution is reached in a single Newton step. The reason for this approach is two-fold. First, it provides an identical user interface for linear and nonlinear problems. Second, it enables the efficient handling of constraints for when inhomogeneous Dirichlet boundary conditions are used.</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;To write the above equations in terms of a Newton iteration, the solution, \f$u\f$, can be written as the sum of an initial guess, \f$u_0\f$, and an update, \f$\Delta u\f$:</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;\f$</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;R(u) = R(u_0 + \Delta u) = R(u_0) +  \int_{\Omega} \left. \frac{\delta R(u)}{\delta u}\right|_{u=u_0} \Delta u ~dV = 0</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;\f$</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;In this case, the equation is linear and the variation derivative is trivial:</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;\f$</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;R(u_0 + \Delta u) =  \int_{\Omega}   \nabla w :  C(\eta_1, \eta_2, \eta_3) : \left( \epsilon(u_0 + \Delta u) - \epsilon^0(c,\eta_1, \eta_2, \eta_3)\right) ~dV = \int_{\Omega}   \nabla w :  C(\eta_1, \eta_2, \eta_3) : \left( \epsilon(u_0) + \epsilon(\Delta u) - \epsilon^0(c,\eta_1, \eta_2, \eta_3)\right) ~dV = 0</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;\f$</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;Rearranging yields:</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;\f$</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;\int_{\Omega} \nabla w : \underbrace{C : \nabla (\epsilon(\Delta u))}_{eqx_{u}^{LHS}} dV = -\int_{\Omega}   \nabla w : \underbrace{C :(\epsilon(u_0)-\epsilon^0)}_{eqx_{u}^{RHS}} ~dV</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;\f$</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;The above values of \f$eqx_{u}^{LHS}\f$ and \f$eqx_{u}^{RHS}\f$ are used to define the residuals in the equations.h file. A similar process can be undertaken for other TIME_INDEPENDENT problems.</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;Here is the &#39;equationLHS&#39; function from the precipitateEvolution example application:</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;```</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;template &lt;int dim, int degree&gt;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;void customPDE&lt;dim,degree&gt;::equationLHS(variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; variable_list,</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;       dealii::Point&lt;dim, dealii::VectorizedArray&lt;double&gt; &gt; q_point_loc) const {</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;// --- Getting the values and derivatives of the model variables ---</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;//n1</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;scalarvalueType n1 = variable_list.get_scalar_value(1);</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;//n2</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;scalarvalueType n2 = variable_list.get_scalar_value(2);</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;//n3</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;scalarvalueType n3 = variable_list.get_scalar_value(3);</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;//u</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;vectorgradType Dux = variable_list.get_change_in_vector_gradient(4);</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;// --- Setting the expressions for the terms in the governing equations ---</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;vectorgradType eqx_Du;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;// Interpolation functions</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;scalarvalueType h1V = (10.0*n1*n1*n1-15.0*n1*n1*n1*n1+6.0*n1*n1*n1*n1*n1);</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;scalarvalueType h2V = (10.0*n2*n2*n2-15.0*n2*n2*n2*n2+6.0*n2*n2*n2*n2*n2);</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;scalarvalueType h3V = (10.0*n3*n3*n3-15.0*n3*n3*n3*n3+6.0*n3*n3*n3*n3*n3);</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;// Take advantage of E being simply 0.5*(ux + transpose(ux)) and use the dealii &quot;symmetrize&quot; function</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;dealii::Tensor&lt;2, dim, dealii::VectorizedArray&lt;double&gt; &gt; E;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;E = symmetrize(Dux);</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;// Compute stress tensor (which is equal to the residual, Rux)</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;if (n_dependent_stiffness == true){</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;   dealii::Tensor&lt;2, CIJ_tensor_size, dealii::VectorizedArray&lt;double&gt; &gt; CIJ_combined;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;   CIJ_combined = CIJ_Mg*(constV(1.0)-h1V-h2V-h3V) + CIJ_Beta*(h1V+h2V+h3V);</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;   computeStress&lt;dim&gt;(CIJ_combined, E, eqx_Du);</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;}</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;else{</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;   computeStress&lt;dim&gt;(CIJ_Mg, E, eqx_Du);</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;}</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;// --- Submitting the terms for the governing equations ---</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;variable_list.set_vector_gradient_term_LHS(4,eqx_Du);</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;}</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;```</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;Like the functions for the RHS, equationLHS takes variables_list and q_point_loc as inputs. However, because only one TIME_INDEPENDENT equation is solved at a time, the output are the terms for a single governing equation. As in \emph{residualRHS}, the model variable values and derivatives are given convenient names at the start of the file. The equationLHS function has a new option for getting variable values and derivatives, here one can access the change in the value of one of the variables or its derivatives. The function name is ```get_change_in_vector_gradient``` above. The other options are ```get_change_in_scalar_value```, ```get_change_in_scalar_gradient```, ```get_change_in_scalar_hessian```, ```get_change_in_vector_value```, and ```get_change_in_vector_hessian```.  Similar to the RHS functions, the value of eqx_Du is set and then used to set the appropriate residual for variables_list (in this case the vector residual term for the fourth variable).</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;If multiple TIME_INDEPENDENT equations need to be solved, you will need to use conditional statements to calculate the proper residual depending on the elliptic equation being solved. The index of the field being solved can be accessed using the ```this-$&gt;$currentFieldIndex``` statement.</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;## ICs_and_BCs.cc</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;The file &#39;&#39;ICs_and_BCs.cc&#39;&#39; contains the initial conditions for the primary variables as well as the expressions for non-uniform Dirichlet boundary conditions, if present. The file contains two functions: setInitialCondition and setNonUniformDirichletBCs.</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="app__files_8md.html">app_files.md</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
